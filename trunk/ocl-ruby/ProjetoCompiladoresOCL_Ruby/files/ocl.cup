package analisadorSintatico;

/*********************************************************
* Universidade Federal de Campina Grande - UFCG          *
* Centro de Engenharia Eletrica e Informatica - CEEI     *
* Departamento de Sistemas e Computacao - DSC            *
*                                                        *
* Projeto da disciplina de Compiladores, 2011.1          *
* Analisador Sintatico para OCL                          *
*                                                        *
* Grupo: Francisco Demontie dos Santos Junior - 20911084 *
*        Izabela Vanessa de Almeida Melo - 20811018      *
*        Savyo Igor da Nobrega Santos - 20811034         *
*********************************************************/

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import analisadorSemantico.SemanticAnalyzer;
import analisadorSemantico.Node;

parser code {:
	
	public List<String> log = new ArrayList<String>();
	public List<String> errorLog = new ArrayList<String>();
	public SemanticAnalyzer as = new SemanticAnalyzer();
	
	public Symbol getCurrentToken() {
		return cur_token;
	}
	
	/* Overrides */
	@Override
	public void debug_message(String message) {
		if (message.equals("# Initializing parser"))
			message = "Inicializando o parser";
		if (message.contains("# Goto state #"))
			message = message.replace("# Goto state ", "# Goto para o estado ");
		if (message.contains("# Current Symbol is #")){
			message = message.replace("# Current Symbol is ", "O simbolo atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains("# Current token is #")){
			message = message.replace("# Current token is ", "O token atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains(" Attempting error recovery"))
			message = "\nRotina de tratamento de erros: tentando reparar o erro";
		if (message.contains("Error recovery fails"))
			message = "Recuperacao de erro falhou";
		if (message.contains("Finding recovery state") | message.contains("Pop stack by one") | message.contains("No recovery state"))
			return;
		log.add(message + "\n");
	}
	
	@Override
  	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		debug_message("# Reduce com a producao #" + prod_num + " [NT=" + nt_num
				+ ", " + "SZ=" + rhs_size + "]");
	}

	@Override
	public void debug_shift(Symbol shift_tkn) {
		debug_message("# Shift sob o termo " + Tokens.getTokenName(shift_tkn.sym) + " para o estado #"
				+ shift_tkn.parse_state);
	}
	
	@Override
	public void report_error(String message, Object info) {
		String token = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			if (s.value != null){
				token = s.value.toString();
			} 
			else {
				token = Tokens.getTokenName(s.sym);
			}
			errorLog.add(message + ": token \" " + token + " \"" + " na linha " + (s.left+1));
		}
		else
			errorLog.add(message);
	}
	
	@Override
	public void report_fatal_error(String message, Object info) throws excecoes.FatalErrorException {
		report_error(message, info);
		done_parsing();
		String linha = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			linha = " na linha " + (s.left+1);
		}
		throw new excecoes.FatalErrorException("na analise sintatica" + linha);
	}
	
	@Override
	public void syntax_error(Symbol cur_token) {
		report_error("Erro sintatico", cur_token);
	}
	
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws excecoes.FatalErrorException {
		String token = " na linha " + (cur_token.left+1);
		if (cur_token.value != null)
			token = ": token " + cur_token.value + token;
		throw new excecoes.FatalErrorException("na analise sintatica" + token + ". Impossivel reparar e continuar a analise.");
    }
	
:}

/*Terminais*/
terminal CONTEXT, PRE, POST;
terminal IF, THEN, ELSE, ENDIF;
terminal LPAREN, RPAREN, LCURLY, RCURLY;
terminal PIPE, POINT_POINT, COMA;
terminal POINTS, FOUR_POINTS, POINT, ARROW;
terminal STAR, DIV, PLUS, MINUS;
terminal AND, OR, XOR, IMPLIES, NOT;
terminal EQ, LT, LE, GT, GE, NE;
terminal AROBAPRE, SELF, RESULT;
terminal String OCL_SUPER_TYPE, OCL_BASIC_TYPE, OCL_COLLECTION;
terminal String STRING;
terminal Integer INT;
terminal Float FLOAT;
terminal Boolean BOOL;
terminal Object ID;

/*Nao terminais*/
non terminal initialRule, initialRuleAux;
non terminal constraint;
non terminal contextDeclaration, constraintBody, stereotype;
non terminal classifierType, operationContext;
non terminal formalParameterList, formalParameter;
non terminal expression, logicalExpression, logicalOperator;
non terminal relationalExpression, relationalOperator;
non terminal additiveExpression, multiplicativeExpression, unaryExpression, unaryOperator;
non terminal postfixExpression, postfixExpressionAux, featureAccess, primaryExpression;
non terminal litteralCollection, expressionListOrRange, litteral;
non terminal ifExpression, featureCall, parameters;
non terminal actualParameterList, typeName, oclType;
non terminal pathName;
non terminal constraintAux, formalParameterListAux, logicalExpressionAux;
non terminal additiveExpressionAux, multiplicativeExpressionAux;
non terminal expressionListOrRangeAux, declarator, declaratorAux;
non terminal actualParameterListAux, pathNameAux;
non terminal featureCallCollection, collectionParameters;

/*Precedencias*/
precedence left COMA;
precedence left IMPLIES;
precedence left NOT;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NE;
precedence left LT, GT, GE, LE;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT;
precedence left POINT, ARROW;
precedence left AROBAPRE;

/*Regras da gramatica*/
start with initialRule;

initialRule ::= constraint:c1 initialRuleAux:ira1;

initialRuleAux ::= constraint:c1 initialRuleAux:ira1 
				| ;

constraint ::= contextDeclaration:cd1 constraintBody:cb1 constraintAux:ca1;

constraintAux ::= constraintBody:cb1 constraintAux:ca1 
			   | ;

contextDeclaration ::= CONTEXT operationContext:oc1;

constraintBody ::= stereotype:s1 ID:id POINTS expression:exp1
					| stereotype:s1 POINTS expression:exp1;

stereotype ::= PRE {: parser.as.setStereotype("pre"); :}
			| POST {: parser.as.setStereotype("post"); :};

classifierType ::= pathName:pn;

operationContext ::= classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS classifierType:ct2
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS oclType:ocltype1
					 | classifierType:ct1 LPAREN RPAREN POINTS classifierType:ct2
					 | classifierType:ct1 LPAREN RPAREN POINTS oclType:ocltype1
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN
					 | classifierType:ct1 LPAREN RPAREN;

formalParameterList ::= formalParameter:fp1 formalParameterListAux:fpla1;

formalParameterListAux ::= COMA formalParameter:fp1 formalParameterListAux:fpla1 
					    | ;

formalParameter ::= ID:id POINTS typeName:tn;

expression ::= logicalExpression:le1;

logicalExpression ::= relationalExpression:re1 logicalExpressionAux:lea1;

logicalExpressionAux ::= logicalOperator:lo1 relationalExpression:re1 logicalExpressionAux:lea1
					  | ;

logicalOperator ::= AND
			     | OR
				 | XOR
				 | IMPLIES;

relationalExpression ::= additiveExpression:ae1 relationalOperator:ro1 additiveExpression:ae2
						 | additiveExpression:ae1;

relationalOperator ::= EQ
					| GT
					| LT
					| GE
					| LE
					| NE;

additiveExpression ::= multiplicativeExpression:me1 additiveExpressionAux:aea1;

additiveExpressionAux ::= PLUS multiplicativeExpression:me1 additiveExpressionAux:aea1
								| MINUS multiplicativeExpression:me1 additiveExpressionAux:aea1
								| ;

multiplicativeExpression ::= unaryExpression:ue1 multiplicativeExpressionAux:mea1;

multiplicativeExpressionAux ::= STAR unaryExpression:ue1 multiplicativeExpressionAux:mea1
								| DIV unaryExpression:ue1 multiplicativeExpressionAux:mea1
								| ;

unaryExpression ::= unaryOperator:uo1 postfixExpression:pfe1
			     | postfixExpression:pfe1;

unaryOperator ::= NOT
			   | MINUS;

postfixExpression ::= primaryExpression:pe1 postfixExpressionAux:pfea1
				   | SELF featureAccess:fa1
				   | SELF AROBAPRE {: parser.as.checkStereotype("@pre"); :} featureAccess:fa1;

postfixExpressionAux ::= POINT featureCall:fCall1 postfixExpressionAux:pfea1
					  | ARROW featureCallCollection:fCol1 postfixExpressionAux:pfea1 
					  | ;

featureAccess ::=  POINT featureCall:fCall1 postfixExpressionAux:pfea1
			   | ;

primaryExpression ::= litteralCollection:lc1
		           | litteral:l1 {: RESULT = l1 ;:}
				   | RESULT {: parser.as.checkStereotype("result"); :} 
				   | featureCall:fCall1 {: RESULT = fCall1 ;:} 
				   | LPAREN expression:exp1 RPAREN 
				   | ifExpression:ifexp1;

litteralCollection ::= OCL_COLLECTION:collection1 LCURLY expressionListOrRange:elor1 RCURLY
						| OCL_COLLECTION:collection1 LCURLY RCURLY;

expressionListOrRange ::= expression:exp1 COMA expression:exp2 expressionListOrRangeAux:elora1
							| expression:exp1 POINT_POINT expression:exp2;

expressionListOrRangeAux ::= COMA expression:exp1 expressionListOrRangeAux:elora1;

ifExpression ::= IF expression:exp1 THEN expression:exp2 ELSE expression:exp3 ENDIF;

featureCall ::= pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre"); :} parameters:params1
				| pathName:pn parameters:params1 {: RESULT	= pn; :}
				| pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre"); :}
				| pathName:pn;

featureCallCollection ::= pathName:pn collectionParameters:params {: parser.as.checkCollectionOperation(((Node)pn).toString(), ((Node)params).getType()); :};

collectionParameters ::= LPAREN declarator:d1 expression:exp1 RPAREN
				| LPAREN declarator:d1 RPAREN
				| LPAREN expression:exp1 RPAREN
				| LPAREN RPAREN {: Node node = new Node();
				                   node.setType("void");
				                   RESULT = node; :};

parameters ::= LPAREN actualParameterList:apl1 RPAREN;

declarator ::= ID:id declaratorAux:da1 POINTS typeName:tn PIPE
				| ID:id declaratorAux:da1 PIPE;

declaratorAux ::= COMA ID:id declaratorAux:da1 | ;
			
actualParameterList ::= expression:exp1 actualParameterListAux:apla1 
						| ;

actualParameterListAux ::= COMA expression:exp1 actualParameterListAux:apla1 | ;

typeName ::= pathName:pn
		  | oclType:ocltype1;

oclType ::= OCL_SUPER_TYPE:super1
		 | OCL_BASIC_TYPE:basic1 
		 | OCL_COLLECTION:collection1 LPAREN typeName:tn RPAREN;

pathName ::= ID:id pathNameAux:pna {: RESULT = new Node((String)id + ((Node)pna).toString()); :};

pathNameAux ::= FOUR_POINTS ID:id pathNameAux:pna {: RESULT = new Node("::" + (String)id + ((Node)pna).toString()); :} 
				| {: RESULT = new Node("") ; :};

litteral ::= INT:int1 {: RESULT = new Node(int1, "Integer"); :}
		| FLOAT:float1 {: RESULT = new Node(float1, "Float"); :}
		| STRING:string1 {: RESULT = new Node(string1, "String"); :} 
		| BOOL:bool1 {: RESULT = new Node(bool1, "Boolean"); :};