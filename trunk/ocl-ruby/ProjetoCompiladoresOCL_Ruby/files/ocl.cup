package analisadorSintatico;

/*********************************************************
* Universidade Federal de Campina Grande - UFCG          *
* Centro de Engenharia Eletrica e Informatica - CEEI     *
* Departamento de Sistemas e Computacao - DSC            *
*                                                        *
* Projeto da disciplina de Compiladores, 2011.1          *
* Analisador Sintatico e Semantico para OCL              *
*                                                        *
* Grupo: Francisco Demontie dos Santos Junior - 20911084 *
*        Izabela Vanessa de Almeida Melo - 20811018      *
*        Savyo Igor da Nobrega Santos - 20811034         *
*********************************************************/

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import analisadorSemantico.SemanticAnalyzer;
import analisadorSemantico.Node;
import geradorDeCodigo.CodeGenerator;

parser code {:
	
	public List<String> log = new ArrayList<String>();
	public List<String> errorLog = new ArrayList<String>();
	public SemanticAnalyzer as = new SemanticAnalyzer();
	
	public Symbol getCurrentToken() {
		return cur_token;
	}
	
	/* Overrides */
	@Override
	public void debug_message(String message) {
		if (message.equals("# Initializing parser"))
			message = "Inicializando o parser";
		if (message.contains("# Goto state #"))
			message = message.replace("# Goto state ", "# Goto para o estado ");
		if (message.contains("# Current Symbol is #")){
			message = message.replace("# Current Symbol is ", "O simbolo atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains("# Current token is #")){
			message = message.replace("# Current token is ", "O token atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains(" Attempting error recovery"))
			message = "\nRotina de tratamento de erros: tentando reparar o erro";
		if (message.contains("Error recovery fails"))
			message = "Recuperacao de erro falhou";
		if (message.contains("Finding recovery state") | message.contains("Pop stack by one") | message.contains("No recovery state"))
			return;
		log.add(message + "\n");
	}
	
	@Override
  	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		debug_message("# Reduce com a producao #" + prod_num + " [NT=" + nt_num
				+ ", " + "SZ=" + rhs_size + "]");
	}

	@Override
	public void debug_shift(Symbol shift_tkn) {
		debug_message("# Shift sob o termo " + Tokens.getTokenName(shift_tkn.sym) + " para o estado #"
				+ shift_tkn.parse_state);
	}
	
	@Override
	public void report_error(String message, Object info) {
		String token = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			if (s.value != null){
				token = s.value.toString();
			} 
			else {
				token = Tokens.getTokenName(s.sym);
			}
			errorLog.add(message + ": token \" " + token + " \"" + " na linha " + (s.left+1));
		}
		else
			errorLog.add(message);
	}
	
	@Override
	public void report_fatal_error(String message, Object info) throws excecoes.FatalErrorException {
		report_error(message, info);
		done_parsing();
		String linha = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			linha = " na linha " + (s.left+1);
		}
		throw new excecoes.FatalErrorException("na analise sintatica" + linha);
	}
	
	@Override
	public void syntax_error(Symbol cur_token) {
		report_error("Erro sintatico", cur_token);
	}
	
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws excecoes.FatalErrorException {
		String token = " na linha " + (cur_token.left+1);
		if (cur_token.value != null)
			token = ": token " + cur_token.value + token;
		throw new excecoes.FatalErrorException("na analise sintatica" + token + ". Impossivel reparar e continuar a analise.");
    }
	
:}

/*Terminais*/
terminal CONTEXT, PRE, POST;
terminal IF, THEN, ELSE, ENDIF;
terminal LPAREN, RPAREN, LCURLY, RCURLY;
terminal PIPE, POINT_POINT, COMA;
terminal POINTS, FOUR_POINTS, POINT, ARROW;
terminal STAR, DIV, PLUS, MINUS;
terminal AND, OR, XOR, IMPLIES, NOT;
terminal EQ, LT, LE, GT, GE, NE;
terminal AROBAPRE, SELF, RESULT;
terminal String OCL_SUPER_TYPE, OCL_BASIC_TYPE, OCL_COLLECTION;
terminal String STRING;
terminal Integer INT;
terminal Float FLOAT;
terminal Boolean BOOL;
terminal Object ID;

/*Nao terminais*/
non terminal initialRule, initialRuleAux;
non terminal constraint;
non terminal contextDeclaration, constraintBody, stereotype;
non terminal classifierType, operationContext;
non terminal formalParameterList, formalParameter;
non terminal expression, logicalExpression, logicalOperator;
non terminal relationalExpression, relationalOperator;
non terminal additiveExpression, multiplicativeExpression, unaryExpression, unaryOperator;
non terminal postfixExpression, postfixExpressionAux, featureAccess, primaryExpression;
non terminal litteralCollection, expressionListOrRange, litteral;
non terminal ifExpression, featureCall, parameters;
non terminal actualParameterList, typeName, oclType;
non terminal pathName;
non terminal constraintAux, formalParameterListAux, logicalExpressionAux;
non terminal additiveExpressionAux, multiplicativeExpressionAux;
non terminal expressionListOrRangeAux, declarator, declaratorAux;
non terminal actualParameterListAux, pathNameAux;
non terminal featureCallCollection, collectionParameters;
non terminal relationalExpressionAux;

/*Precedencias*/
precedence left COMA;
precedence left IMPLIES;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NE;
precedence left LT, GT, GE, LE;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT;
precedence left POINT, ARROW;
precedence left AROBAPRE;

/*Regras da gramatica*/
start with initialRule;

initialRule ::= constraint:c1 initialRuleAux:ira1;

initialRuleAux ::= constraint:c1 initialRuleAux:ira1 
				| ;

constraint ::= contextDeclaration:cd1 constraintBody:cb1 constraintAux:ca1 {: 
								String code = ((Node)cd1).getCode() + ((Node)cb1).getCode() + ((Node)ca1).getCode() + CodeGenerator.getInstance().getAllPre()
								 + CodeGenerator.getInstance().getAllPost() + CodeGenerator.getInstance().getMain() + "\nend";
								CodeGenerator.getInstance().writeToFile(code);
								CodeGenerator.getInstance().reset();
								 :};

constraintAux ::= constraintBody:cb1 constraintAux:ca1 {: Node node = new Node();
														  node.setCode(((Node)cb1).getCode() + ((Node)ca1).getCode()); :}
			   | {: RESULT = new Node(); :};

contextDeclaration ::= CONTEXT operationContext:oc1 {: RESULT = oc1; :};

constraintBody ::= stereotype:s1 ID:id POINTS expression:exp1 {: if (((String)s1).equals("Pre"))
																	CodeGenerator.getInstance().addPre(parser.as.getContextMethod(),
																	  "checkPre" + ((String)id) + parser.as.getContextMethod().substring(0, 1).toUpperCase() 
																	  + parser.as.getContextMethod().substring(1));
																 else
																 	CodeGenerator.getInstance().addPost(parser.as.getContextMethod(),
																 	  "checkPost" + ((String)id) + parser.as.getContextMethod().substring(0, 1).toUpperCase() 
																	  + parser.as.getContextMethod().substring(1));
																 Node node = new Node();
																 RESULT = node; :}
					| stereotype:s1 POINTS expression:exp1 {: if (((String)s1).equals("Pre"))
																CodeGenerator.getInstance().addPre(parser.as.getContextMethod());
															  else
															    CodeGenerator.getInstance().addPost(parser.as.getContextMethod());
															  Node node = new Node();
															  RESULT = node; :};

stereotype ::= PRE {: parser.as.setStereotype("pre"); RESULT = "Pre"; :}
			| POST {: parser.as.setStereotype("post"); RESULT = "Post"; :};

classifierType ::= pathName:pn {: Node node = (Node)pn;
								  String[] separate = node.toString().split("::");
								  String classe = separate[separate.length-2];
								  String metodo = separate[separate.length-1];
								  node.setCode(CodeGenerator.getInstance().getClassCode(classe));
								  CodeGenerator.getInstance().setFileName(classe);
								  CodeGenerator.getInstance().addContextMethod(metodo);
								  RESULT = node; :};

operationContext ::= classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS classifierType:ct2 {: parser.as.checkOperationContext((Node)ct1, (Node)fpl1, (Node)ct2, ct2left); :}
					 																 							
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS oclType:ocltype1 {: parser.as.checkOperationContext((Node)ct1, (Node)fpl1, (Node)ocltype1, ocltype1left); :}
					 
					 | classifierType:ct1 LPAREN RPAREN POINTS classifierType:ct2 {: parser.as.checkOperationContext((Node)ct1, new Node(), (Node)ct2, ct2left); :}
					 																 	
					 | classifierType:ct1 LPAREN RPAREN POINTS oclType:ocltype1 {: parser.as.checkOperationContext((Node)ct1, new Node(), (Node)ocltype1, ocltype1left); :}
					 																	
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN {: parser.as.setContext(((Node)ct1).toString(), (Node)fpl1, ct1left); :}
					 | classifierType:ct1 LPAREN RPAREN {: parser.as.setContext(((Node)ct1).toString(), new Node(), ct1left);
					 									   RESULT = ct1; :};

formalParameterList ::= formalParameter:fp1 formalParameterListAux:fpla1 {: Node node = (Node)fpla1;
																			node.addElement((Node)fp1);
																			RESULT = node;
																		 :} ;

formalParameterListAux ::= COMA formalParameter:fp1 formalParameterListAux:fpla1 {: Node node = (Node)fpla1;
																					node.addElement((Node)fp1);
																					RESULT = node;
																				 :}
					    | {: RESULT = new Node(); :};

formalParameter ::= ID:id POINTS typeName:tn {: Node node = new Node((String)id, ((Node)tn).toString());
												node.setCollection(((Node)tn).isCollection());
												parser.as.declareID(node, idleft);
												RESULT = node; :};

expression ::= logicalExpression:le1 {: Node node = (Node)le1; node.setCode(((Node)le1).getCode()); 
										System.out.println("expressao: " + node.getCode());
										if(((Node)le1).isIfExpression){
                                            node.isIfExpression = true;
                                        }
										RESULT = node;:};

logicalExpression ::= relationalExpression:re1 logicalExpressionAux:lea1 {: Node node = new Node(); 
                                                                            if (lea1 == null)
                                                                                node = (Node)re1;
                                                                            else{
                                                                            	String type = parser.as.maxType(((Node)re1).getType(), ((Node)lea1).getType(), re1left);
                                                                                if ((type == null) || !type.equals("Boolean")){
                                                                                	type = "Boolean";
                                                                                }
                                                                                node.setType(type);
                                                                          		if(((Node)lea1).isImplies){
                                                                          			node.setCode(" not " + "(" +((Node)re1).getCode()+ ")" + ((Node)lea1).getCode());
                                                                          		}else{
                                                                          		
                                                                          			node.setCode(((Node)re1).getCode() + ((Node)lea1).getCode());
                                                                          		}
                                                                          	}
                                                                          	if(((Node)re1).isIfExpression){
                                                                           		node.isIfExpression = true;
                                                                           	}
                                                                          	RESULT = node; :};

logicalExpressionAux ::= logicalOperator:lo1 relationalExpression:re1 logicalExpressionAux:lea1 {: Node node = new Node(); 
                                                                                     		 	   String type;
                                                                                     		 	   if(((String)lo1).equals("implies")){
                                                                                     		 	   	node.isImplies = true;
                                                                                     		 	   }
                                                                                     		 	   if (lea1 == null){
                                                                                     		 	      type = ((Node)re1).getType();
                                                                                     		 	      if (!type.equals("Boolean")){
                                                                                     		 	         parser.as.error(re1left, "operador " + (String)lo1 + " so eh definido para valores booleanos");
                                                                                        	 	      }
                                                                                        	 	      node.setType(type);
                                                                                        	 	      if(((String)lo1).equals("xor")){
                                                                                        	 	      	node.setCode(" ^ " + ((Node)re1).getCode());
                                                                                        	       	  
                                                                                        	 	      }else if(((String)lo1).equals("implies")){
                                                                                        	 	      	node.setCode(" or " + ((Node)re1).getCode());
                                                                                        	 	      }else{
                                                                                        	 	      	node.setCode(" " + lo1 + " " + ((Node)re1).getCode());
                                                                                        	       	  }
                                                                                        	       } else{
                                                                                     		 	      type = parser.as.maxType(((Node)re1).getType(), ((Node)lea1).getType(), re1left);
                                                                                     		 	      if ((type == null) || !type.equals("Boolean")){
                                                                                     		 		     type = "Boolean";
                                                                                     		 		  }
                                                                              				 		   
                                                                              				 		  if(((String)lo1).equals("xor")){
                                                                                        	 	      	node.setCode(" ^ " + "(" +((Node)re1).getCode() + ((Node)lea1).getCode()+")" );
                                                                                        	 	      }else if(((String)lo1).equals("implies")){
                                                                                        	 	      	node.setCode(" or " + "(" +((Node)re1).getCode() + ((Node)lea1).getCode() + ")");
                                                                                        	 	      }else{
                                                                              				 		  	node.setCode(" " + lo1 + " " + ((Node)re1).getCode() + ((Node)lea1).getCode() );
                                                                          			 		 	   	  }
                                                                          			 		 	   }
                                                                          			 		 	   node.setOperation((String)lo1);
                                                                          			 		 	   if(((Node)re1).isIfExpression){
                                                                           							node.isIfExpression = true;
                                                                           							}
                                                                          			 		 	   
                                                                          			 		 	   RESULT = node; :}
					  | ;

logicalOperator ::= AND {: RESULT = "and"; :}
			     | OR {: RESULT = "or"; :}
				 | XOR {: RESULT = "xor"; :}
				 | IMPLIES {: RESULT = "implies"; //TODO:};

relationalExpression ::= additiveExpression:ae1 relationalExpressionAux:rea {: Node node = new Node();
																			   if (rea == null)
																			      node = (Node)ae1;
																			   else{
                                                                                  String type = parser.as.maxType(((Node)ae1).getType(), ((Node)rea).getType(), ae1left);
                                                                                  if (type == null)
                                                                                     type = ((Node)rea).getType();
                                                                                  parser.as.checkRelationalOp((String)((Node)rea).getOperation(), type);
                                                                                  node.setType("Boolean");
                                                                                  node.setCode(((Node)ae1).getCode() + ((Node)rea).getCode());
                                                                                  if(((Node)rea).isIfExpression){
                                                                           			node.isIfExpression = true;
                                                                           			String[] lista = ((Node)rea).getCode().split(" & ");
                                                                           			
                                                                           			String operator = ((Node)rea).getOperation();
                                                                           			lista[0] = lista[0].replace("==", "");
                                                                           			if(operator.equals("=")){
                                                                           				operator = " == ";
                                                                           			}
                                                                           			node.setCode(((Node)ae1).getCode() + operator + " " + lista[0] + "\n" + ((Node)ae1).getCode() + operator + " " + lista[1]);
                                                                           		  	
                                                                           			}
                                                                          	   }
                                                                          	   
                                                                          	   RESULT = node;
																			:}
						 | additiveExpression:ae1 {: RESULT = ae1; :};

relationalExpressionAux ::= relationalOperator:ro1 additiveExpression:ae2 relationalExpressionAux:rea {: Node node = new Node(); 
                                                                                     		 	   		 String type;
                                                                                     		 	   		 type = parser.as.maxType(((Node)ae2).getType(), ((Node)rea).getType(), ae2left);
                                                                                     		 	      	 parser.as.checkRelationalOp((String)((Node)rea).getOperation(), type);
                                                                                     		 	      	 node.setType("Boolean");
                                                                                     		 	      	 node.setOperation((String)ro1);
                                                                                     		 	      	 if(ro1.equals("=")){
                                                                                     		 	      	 	node.setCode(" == " + ((Node)ae2).getCode() + ((Node)rea).getCode());
                                                                                     		 	      	 }else{
                                                                                     		 	      	 	node.setCode(" " + ro1 + " " + ((Node)ae2).getCode() + ((Node)rea).getCode());
                                                                                     		 	      	 	
                                                                                     		 	      	 }
                                                                                     		 	      	 if(((Node)rea).isIfExpression){
                                                                           									node.isIfExpression = true;
                                                                           									String[] lista = ((Node)rea).getCode().split(" & ");
                                                                           									lista[0] = lista[0].replace("==", "");
                                                                           									if(ro1.equals("=")){
                                                                                     		 	      	 		node.setCode(((Node)ae2).getCode() + " == " + lista[0] + "\n" + ((Node)ae2).getCode() + " == " + " " + lista[1]);
                                                                           		  							
                                                                                     		 	      	 	}else{
                                                                                     		 	      	 		node.setCode(((Node)ae2).getCode() + (String) ro1 + " " + lista[0] + "\n" + ((Node)ae2).getCode() + (String) ro1 + " " + lista[1]);
                                                                           		  							
                                                                                     		 	      	 	}
                                                                           		  						}
                                                                                     		 	      	 
                                                                                     		 	      	 
                                                                          			 		 	   		 RESULT = node; :}
						| relationalOperator:ro1 additiveExpression:ae2 {: Node node = (Node)ae2;
																		   node.setOperation((String)ro1);
																		   if(ro1.equals("=")){
                                                                           	node.setCode(" == " + ((Node)ae2).getCode());
                                                                           }else{
																			node.setCode(" " + ro1 + " " + ((Node)ae2).getCode());
                                                                           }
                                                                           if(((Node)ae2).isIfExpression){
                                                                           	node.isIfExpression = true;
                                                                           }
																		  RESULT = node; :};

relationalOperator ::= EQ {: RESULT = "="; :}
					| GT {: RESULT = ">"; :}
					| LT {: RESULT = "<"; :}
					| GE {: RESULT = ">="; :}
					| LE {: RESULT = "<="; :}
					| NE {: RESULT = "<>"; :};

additiveExpression ::= multiplicativeExpression:me1 additiveExpressionAux:aea1 
					{: Node node = parser.as.checkTypesOpArithmetic((Node)me1, (Node)aea1, me1left);
					if(aea1 == null){
						node.setCode(((Node)me1).getCode());
						if(((Node)me1).isIfExpression){
							node.isIfExpression = true;
						}
                    
					}else{
						node.setCode(((Node)me1).getCode() + ((Node)aea1).getCode());
                    
					}
                    RESULT = node; :};

additiveExpressionAux ::= PLUS multiplicativeExpression:me1 additiveExpressionAux:aea1 
						{: Node node = parser.as.checkTypesOpArithmeticAux((Node)me1, (Node)aea1, "+", me1left);
                           if(aea1 == null){
                              node.setCode(" + " + ((Node)me1).getCode());
                           }else{
                           	  node.setCode(" + " + ((Node)me1).getCode() + ((Node)aea1).getCode());
                          }
                           RESULT = node; :}
							
								| MINUS multiplicativeExpression:me1 additiveExpressionAux:aea1 
								{: Node node = parser.as.checkTypesOpArithmeticAux((Node)me1, (Node)aea1, "-", me1left);
                                   if(aea1 == null){
                                   	node.setCode(" - " + ((Node)me1).getCode());
                                   }else{
                                   	node.setCode(" - " + ((Node)me1).getCode() + ((Node)aea1).getCode());
                                   }
                                   RESULT = node; :}
								| ;

multiplicativeExpression ::= unaryExpression:ue1 multiplicativeExpressionAux:mea1 
						{: Node node = parser.as.checkTypesOpArithmetic((Node)ue1, (Node)mea1, ue1left);
						if(mea1 == null){
							node.setCode(((Node)ue1).getCode());
							if(((Node)ue1).isIfExpression){
								node.isIfExpression = true;
							}
						}else{
							node.setCode(((Node)ue1).getCode() + ((Node)mea1).getCode());
                        
						}
						
                        RESULT = node; :};

multiplicativeExpressionAux ::= STAR unaryExpression:ue1 multiplicativeExpressionAux:mea1 
							{: Node node = parser.as.checkTypesOpArithmeticAux((Node)ue1, (Node)mea1, "*", ue1left);
                            if(mea1 == null){
                            	node.setCode(" * " + ((Node)ue1).getCode());
                            }else{
                            	node.setCode(" * " + ((Node)ue1).getCode() + ((Node)mea1).getCode());
                            }
                            RESULT = node; :}
							    
							    | DIV unaryExpression:ue1 multiplicativeExpressionAux:mea1
							    {: Node node = parser.as.checkTypesOpArithmeticAux((Node)ue1, (Node)mea1, "/", ue1left);
                                if(mea1 == null){
                            		node.setCode(" / " + ((Node)ue1).getCode());
                            	}else{
                            		node.setCode(" / " + ((Node)ue1).getCode() + ((Node)mea1).getCode());
                            	}
                                RESULT = node; :}
								| ;

unaryExpression ::= unaryOperator:uo1 postfixExpression:pfe1 {: Node node = (Node)pfe1;
																if (((String)uo1).equals("not")){
																	if (node.getType().equals("Integer") || node.getType().equals("Float") || node.getType().equals("String"))
																		parser.as.error(pfe1left, "operador 'NOT' nao eh definido para o tipo " + node.getType());	
																} else {
																	if (node.getType().equals("String") || node.getType().equals("Boolean"))
																		parser.as.error(pfe1left, "operador ' - ' nao eh definido para o tipo " + node.getType());
																}
																node.setCode(" " + uo1 + " (" + ((Node)pfe1).getCode() + ") ");
																if(((Node)pfe1).isIfExpression){
																	node.isIfExpression = true;
																}
																RESULT = node;
															 :}
			     | postfixExpression:pfe1 {: RESULT = pfe1; :};

unaryOperator ::= NOT {: RESULT = "not"; :}
			   | MINUS {: RESULT = "-"; :};

postfixExpression ::= primaryExpression:pe1 postfixExpressionAux:pfea1 {: Node node;
                                                                          if (((Node)pfea1).getElements().size() == 0){
                                                                          	node = (Node)pe1;
                                                                          }
                                                                          else{
                                                                          	Iterator<Node> it = ((Node)pfea1).iterator();
                                                                          	Node previous = (Node)pe1;
                                                                          	Node next;
                                                                          	Node aux = null;
                                                                          	while (it.hasNext()){
                                                                          		next = it.next();
                                                                          		if (next.getOperation().equals("->")){
                                                                          			if (!previous.isCollection())
                                                                          				parser.as.error(pe1left, "o identificador " + previous.getValue() + " nao eh uma colecao.");
                                                                          			aux = parser.as.getReturnType(previous.getType(),(String)next.getValue());
                                                                          		}
                                                                          		else if (next.getOperation().equals(".")){
                                                                          			if (previous.isCollection())
                                                                          				parser.as.error(pe1left, "o identificador " + previous.getValue() + " eh uma colecao. Utilize '->' para as operacoes sobre colecoes.");
                                                                          			aux = parser.as.checkFeatureCall(previous.getType(),next, pe1left);
                                                                          		}
                                                                          		previous = aux;
                                                                          	}
                                                                          	node = aux;
                                                                          	node.setCode(((Node)pe1).getCode() + ((Node)pfea1).getCode());
                                                                          }
                                                                          RESULT = node; :}
				   
				   | SELF featureAccess:fa1 {: Node fCall = (Node)fa1;
				   						       Node node = parser.as.checkFeatureCall(parser.as.getContextClass(),fCall, fa1left);
				   						       RESULT = node;//TODO
				   						    :}
				   
				   | SELF AROBAPRE featureAccess:fa1 {: parser.as.checkStereotype("@pre", fa1left);
				   										Node fCall = (Node)fa1;
				   						       			Node node = parser.as.checkFeatureCall(parser.as.getContextClass(),fCall, fa1left);
				   						       			RESULT = node;//TODO :};

postfixExpressionAux ::= POINT featureCall:fCall1 {: Node fCall = (Node)fCall1;
													 Node node = parser.as.checkFeatureCall(parser.as.tipoPrimary,fCall, fCall1left);
													 parser.as.tipoPrimary = node.getType();
													 :} 
												  
												  postfixExpressionAux:pfea1 {: Node node = (Node)pfea1;
																				Node nodeAux = (Node)fCall1;
																				nodeAux.setOperation(".");
																				node.addElement(nodeAux);
																				node.setCode("." + ((Node)fCall1).getCode() + ((Node)pfea1).getCode());
																				RESULT = node; :}
					  | ARROW featureCallCollection:fCol1 postfixExpressionAux:pfea1 {: Node node = (Node)pfea1;
					  																	Node nodeAux = (Node)fCol1;
					  																	nodeAux.setOperation("->");
																						node.addElement(nodeAux);
																						RESULT = node; :}
					  | {: RESULT = new Node(); :};

featureAccess ::=  POINT featureCall:fCall1 postfixExpressionAux:pfea1 {: //TODO: fazer a parte para quando postfixExpAux != null
																		  Node node = new Node();
																		  if (pfea1 == null){
																		  	node = (Node)fCall1;
																		  }
																		  RESULT = node;
																	    :}
			   | ;

primaryExpression ::= litteralCollection:lc1
		           | litteral:l1 {: Node node = (Node)l1; node.setCode(((Node)l1).getCode());RESULT = node;:}
				   | RESULT:r {: parser.as.checkStereotype("result", rleft); 
				   			     if (parser.as.getContextType().equalsIgnoreCase("void"))
				   			     	parser.as.error(rleft, "result nao pode ser usado num contexto de metodo com tipo void.");
				   			     Node node = new Node();
				   			     node.setValue("result");
				   			     node.setType(parser.as.getContextType());
				   			     node.setRole(Node.VARIABLE);
				   			     RESULT = node; //TODO
				   			   :} 
				   | featureCall:fCall1 {: Node fCall = (Node)fCall1;
				   						   Node node = parser.as.checkFeatureCall(parser.as.getContextClass(),fCall, fCall1left);
				   						   node.setCode(((Node)fCall1).getCode());
				   						   RESULT = node;
				   						   parser.as.tipoPrimary = node.getType();
				   						    :}
				   | LPAREN expression:exp1 RPAREN {: Node node = (Node)exp1; 
				   			node.setCode("(" + ((Node)exp1).getCode() + ")"); 
				   			if(((Node)exp1).isIfExpression){
                                 node.isIfExpression = true;
                            }
				   			RESULT = node; :}
				   | ifExpression:ifexp1 {: RESULT = ifexp1; :};

litteralCollection ::= OCL_COLLECTION:collection1 LCURLY expressionListOrRange:elor1 RCURLY
						| OCL_COLLECTION:collection1 LCURLY RCURLY;

expressionListOrRange ::= expression:exp1 COMA expression:exp2 expressionListOrRangeAux:elora1
							| expression:exp1 POINT_POINT expression:exp2;

expressionListOrRangeAux ::= COMA expression:exp1 expressionListOrRangeAux:elora1;

ifExpression ::= IF expression:exp1 THEN expression:exp2 ELSE expression:exp3 ENDIF {: if (!((Node)exp1).getType().equalsIgnoreCase("Boolean"))
																					       parser.as.error(exp1left, "a expressao dentro do if deve ser booleana.");
																					   String type = parser.as.maxType(((Node)exp2).getType(),((Node)exp3).getType(),exp1left);
																					   if (type == null)
																					       type = ((Node)exp2).getType();
																					   Node node = new Node();
																					   node.setType(type);
																					   node.isIfExpression = true;
																					   node.setCode(((Node)exp2).getCode() + " if " +((Node)exp1).getCode() + " & " +((Node)exp3).getCode() + " unless " +((Node)exp1).getCode());
																					   RESULT = node; :};

featureCall ::= pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre", pnleft); :} parameters:params1 {: //TODO 
																										 :}
				| pathName:pn parameters:params1 {:  Node node = new Node(((Node)pn).getValue(), "");
								 		  			 node.setRole(Node.FUNCTION);
								 		  			 node.addAllElements(((Node)params1).getElements());
								 		  			 node.setCode(((Node)pn).getValue() + ((Node)params1).getCode());
								 		  			 RESULT = node;
								 		  			  :}
				| pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre", pnleft);
										  Node node = new Node(((Node)pn).getValue(), "");
								 		  node.setRole(Node.VARIABLE);
								 		  RESULT = node; //TODO soma, mult, div em ruby com arobapre:}
				| pathName:pn {: Node node = new Node(((Node)pn).getValue(), "");
								 node.setCode("" + ((Node)pn).getValue());
								 node.setRole(Node.VARIABLE);
								 RESULT = node; :};

featureCallCollection ::= pathName:pn {: parser.as.opCollection = true; :} collectionParameters:params {: 
                      parser.as.checkCollectionOperation(((Node)pn).toString(), ((Node)params).getType(), pnleft);
                      RESULT = new Node(((Node)pn).toString());
                      parser.as.opCollection = false;
                      :};

collectionParameters ::= LPAREN declarator:d1 expression:exp1 RPAREN {: Node node = new Node();
				                   				   						node.setType(((Node)exp1).getType());
				                   				   						RESULT = node;
				                   				   						parser.as.setDeclarator(false); :}
				| LPAREN declarator:d1 RPAREN {: RESULT = new Node(null, "void");
											  :}
				| LPAREN expression:exp1 RPAREN {: Node node = new Node();
				                   				   node.setType(((Node)exp1).getType());
				                   				   RESULT = node; :}
				| LPAREN RPAREN {: Node node = new Node();
				                   node.setType("void");
				                   RESULT = node; :};

parameters ::= LPAREN actualParameterList:apl1 RPAREN {: Node node = (Node)apl1; node.setCode("(" + ((Node)apl1).getCode() + ")"); RESULT = node; :};

declarator ::= ID:id declaratorAux:da1 POINTS typeName:tn PIPE {: Node node = (Node)da1;
												  				  node.addElement(new Node((String)id));
												  				  RESULT = node; :}
				| ID:id declaratorAux:da1 PIPE {: Node node = (Node)da1;
												  node.addElement(new Node((String)id));
												  RESULT = node;
												  parser.as.setDeclaratorAux(node.getElements());
												  parser.as.setDeclarator(true); :};

declaratorAux ::= COMA ID:id declaratorAux:da1 {: Node node = (Node)da1;
												  node.addElement(new Node((String)id));
												  RESULT = node; :} 
				| {: RESULT = new Node(); :};
			
actualParameterList ::= expression:exp1 actualParameterListAux:apla1 
						{: Node node = new Node();
						   node.addAllElements(((Node)apla1).getElements());
						   node.addElement((Node)exp1);
						   node.setCode(((Node)exp1).getCode() + ((Node)apla1).getCode());
						   RESULT = node;
						:}
						| {: RESULT = new Node(); :};

actualParameterListAux ::= COMA expression:exp1 actualParameterListAux:apla1
						{: Node node = new Node();
						   node.addAllElements(((Node)apla1).getElements());
						   node.addElement((Node)exp1);
						   node.setCode(", " + ((Node)exp1).getCode() + ((Node)apla1).getCode());
						   RESULT = node;
						:}
						 | {: RESULT = new Node(); :};

typeName ::= pathName:pn {: RESULT = pn; :}
		  | oclType:ocltype1 {: RESULT = ocltype1; :};

oclType ::= OCL_SUPER_TYPE:super1 {: RESULT = new Node(super1, super1); :}
		 | OCL_BASIC_TYPE:basic1 {: RESULT = new Node(basic1, basic1); :}
		 | OCL_COLLECTION:collection1 LPAREN typeName:tn RPAREN {: Node node = new Node(((Node)tn).getType(),((Node)tn).getType());
		 														   node.setCollection(true);
		 														   RESULT = node;
		 														 :};

pathName ::= ID:id pathNameAux:pna {: RESULT = new Node((String)id + ((Node)pna).toString()); :};

pathNameAux ::= FOUR_POINTS ID:id pathNameAux:pna {: RESULT = new Node("::" + (String)id + ((Node)pna).toString()); :} 
				| {: RESULT = new Node("") ; :};

litteral ::= INT:int1 {: Node node = new Node(int1, "Integer"); node.setCode("" + int1); RESULT = node; :}
		| FLOAT:float1 {: Node node = new Node(float1, "Float"); node.setCode("" + float1); RESULT = node; :}
		| STRING:string1 {: Node node = new Node(string1, "String"); node.setCode("" + string1); RESULT = node; :} 
		| BOOL:bool1 {: Node node = new Node(bool1, "Boolean");  node.setCode("" + bool1); RESULT = node;:};