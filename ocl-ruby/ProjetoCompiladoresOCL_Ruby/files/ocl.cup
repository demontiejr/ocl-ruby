package analisadorSintatico;

/*********************************************************
* Universidade Federal de Campina Grande - UFCG          *
* Centro de Engenharia Eletrica e Informatica - CEEI     *
* Departamento de Sistemas e Computacao - DSC            *
*                                                        *
* Projeto da disciplina de Compiladores, 2011.1          *
* Analisador Sintatico para OCL                          *
*                                                        *
* Grupo: Francisco Demontie dos Santos Junior - 20911084 *
*        Izabela Vanessa de Almeida Melo - 20811018      *
*        Savyo Igor da Nobrega Santos - 20811034         *
*********************************************************/

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import analisadorSemantico.SemanticAnalyzer;

parser code {:
	
	public List<String> log = new ArrayList<String>();
	public List<String> errorLog = new ArrayList<String>();
	public SemanticAnalyzer as = new SemanticAnalyzer();
	
	public Symbol getCurrentToken() {
		return cur_token;
	}
	
	/* Overrides */
	@Override
	public void debug_message(String message) {
		if (message.equals("# Initializing parser"))
			message = "Inicializando o parser";
		if (message.contains("# Goto state #"))
			message = message.replace("# Goto state ", "# Goto para o estado ");
		if (message.contains("# Current Symbol is #")){
			message = message.replace("# Current Symbol is ", "O simbolo atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains("# Current token is #")){
			message = message.replace("# Current token is ", "O token atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains(" Attempting error recovery"))
			message = "\nRotina de tratamento de erros: tentando reparar o erro";
		if (message.contains("Error recovery fails"))
			message = "Recuperacao de erro falhou";
		if (message.contains("Finding recovery state") | message.contains("Pop stack by one") | message.contains("No recovery state"))
			return;
		log.add(message + "\n");
	}
	
	@Override
  	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		debug_message("# Reduce com a producao #" + prod_num + " [NT=" + nt_num
				+ ", " + "SZ=" + rhs_size + "]");
	}

	@Override
	public void debug_shift(Symbol shift_tkn) {
		debug_message("# Shift sob o termo " + Tokens.getTokenName(shift_tkn.sym) + " para o estado #"
				+ shift_tkn.parse_state);
	}
	
	@Override
	public void report_error(String message, Object info) {
		String token = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			if (s.value != null){
				token = s.value.toString();
			} 
			else {
				token = Tokens.getTokenName(s.sym);
			}
			errorLog.add(message + ": token \" " + token + " \"" + " na linha " + (s.left+1));
		}
		else
			errorLog.add(message);
	}
	
	@Override
	public void report_fatal_error(String message, Object info) throws excecoes.FatalErrorException {
		report_error(message, info);
		done_parsing();
		String linha = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			linha = " na linha " + (s.left+1);
		}
		throw new excecoes.FatalErrorException("na analise sintatica" + linha);
	}
	
	@Override
	public void syntax_error(Symbol cur_token) {
		report_error("Erro sintatico", cur_token);
	}
	
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws excecoes.FatalErrorException {
		String token = " na linha " + (cur_token.left+1);
		if (cur_token.value != null)
			token = ": token " + cur_token.value + token;
		throw new excecoes.FatalErrorException("na analise sintatica" + token + ". Impossivel reparar e continuar a analise.");
    }
	
:}

/*Terminais*/
terminal CONTEXT, PRE, POST;
terminal IF, THEN, ELSE, ENDIF;
terminal LPAREN, RPAREN, LCURLY, RCURLY;
terminal PIPE, POINT_POINT, COMA;
terminal POINTS, FOUR_POINTS, POINT, ARROW;
terminal STAR, DIV, PLUS, MINUS;
terminal AND, OR, XOR, IMPLIES, NOT;
terminal EQ, LT, LE, GT, GE, NE;
terminal AROBAPRE, SELF, RESULT;
terminal String OCL_SUPER_TYPE, OCL_BASIC_TYPE, OCL_COLLECTION;
terminal String STRING;
terminal Integer INT;
terminal Float FLOAT;
terminal Boolean BOOL;
terminal Object ID;

/*Nao terminais*/
non terminal initialRule, initialRuleAux;
non terminal constraint;
non terminal contextDeclaration, constraintBody, stereotype;
non terminal classifierType, operationContext;
non terminal formalParameterList, formalParameter;
non terminal expression, logicalExpression, logicalOperator;
non terminal relationalExpression, relationalOperator;
non terminal additiveExpression, multiplicativeExpression, unaryExpression, unaryOperator;
non terminal postfixExpression, postfixExpressionAux, featureAccess, primaryExpression;
non terminal litteralCollection, expressionListOrRange, litteral;
non terminal ifExpression, featureCall, parameters;
non terminal actualParameterList, typeName, oclType;
non terminal pathName, number;
non terminal constraintAux, formalParameterListAux, logicalExpressionAux;
non terminal additiveExpressionAux, multiplicativeExpressionAux;
non terminal expressionListOrRangeAux, declarator, declaratorAux;
non terminal actualParameterListAux, pathNameAux;

/*Precedencias*/
precedence left COMA;
precedence left IMPLIES;
precedence left NOT;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NE;
precedence left LT, GT, GE, LE;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT;
precedence left POINT, ARROW;
precedence left AROBAPRE;

/*Regras da gramatica*/
start with initialRule;

initialRule ::= constraint:c1 initialRuleAux:ira1 {: RESULT = (String)c1 + (String)ira1 ; System.out.println(RESULT);:};

initialRuleAux ::= constraint:c1 initialRuleAux:ira1 {: RESULT = (String)c1 + (String)ira1 ;:} 
				| {: RESULT = "" ;:};

constraint ::= contextDeclaration:cd1 constraintBody:cb1 constraintAux:ca1 {: RESULT = (String)cd1 + (String)cb1 + (String)ca1 ;:};

constraintAux ::= constraintBody:cb1 constraintAux:ca1 {: RESULT = (String)cb1 + (String)ca1 ;:} 
			   | {: RESULT = "" ;:};

contextDeclaration ::= CONTEXT operationContext:oc1 {: RESULT = "context" + (String)oc1 ;:};

constraintBody ::= stereotype:s1 ID:id POINTS expression:exp1 {: RESULT = (String)s1 + (String)id + ":" + (String)exp1 ;:}
					| stereotype:s1 POINTS expression:exp1 {: RESULT = (String)s1 + ":" + (String)exp1 ;:};

stereotype ::= PRE {: parser.as.setStereotype("pre"); RESULT = "pre" ;:}
			| POST {: parser.as.setStereotype("post"); RESULT = "post" ;:};

classifierType ::= pathName:pn {: RESULT = (String)pn ;:};

operationContext ::= classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS classifierType:ct2 {: RESULT = (String)ct1 + "(" + (String)fpl1 + ")" + ":" + (String)ct2 ;:}
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS oclType:ocltype1  {: RESULT = (String)ct1 + "(" + (String)fpl1 + ")" + ":" + (String)ocltype1 ;:}
					 | classifierType:ct1 LPAREN RPAREN POINTS classifierType:ct2  {: RESULT = (String)ct1 + "(" + ")" + ":" + (String)ct2 ;:}
					 | classifierType:ct1 LPAREN RPAREN POINTS oclType:ocltype1  {: RESULT = (String)ct1 + "(" + ")" + ":" + (String)ocltype1 ;:}
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN  {: RESULT = (String)ct1 + "(" + (String)fpl1 + ")" ;:}
					 | classifierType:ct1 LPAREN RPAREN {: RESULT = (String)ct1 + "(" + ")" ;:};

formalParameterList ::= formalParameter:fp1 formalParameterListAux:fpla1 {: RESULT = (String)fp1 + (String)fpla1 ;:};

formalParameterListAux ::= COMA formalParameter:fp1 formalParameterListAux:fpla1 {: RESULT = "," + (String)fp1 + (String)fpla1 ;:} 
					    | {: RESULT = "" ;:};

formalParameter ::= ID:id POINTS typeName:tn {: RESULT = (String)id + ":" + (String)tn ;:};

expression ::= logicalExpression:le1 {: RESULT = (String)le1 ;:};

logicalExpression ::= relationalExpression:re1 logicalExpressionAux:lea1 {: RESULT = (String)re1 + (String)lea1 ;:};

logicalExpressionAux ::= logicalOperator:lo1 relationalExpression:re1 logicalExpressionAux:lea1 {: RESULT = (String)lo1 + (String)re1 + (String)lea1 ;:}
					  | {: RESULT = "" ;:};

logicalOperator ::= AND {: RESULT = "and" ;:}
			     | OR {: RESULT = "or" ;:}
				 | XOR {: RESULT = "xor" ;:}
				 | IMPLIES {: RESULT = "implies" ;:};

relationalExpression ::= additiveExpression:ae1 relationalOperator:ro1 additiveExpression:ae2 {: RESULT = (String)ae1 + (String)ro1 + (String)ae2 ;:}
						 | additiveExpression:ae1 {: RESULT = (String)ae1 ;:};

relationalOperator ::= EQ {: RESULT = "=" ;:}
					| GT {: RESULT = ">" ;:}
					| LT {: RESULT = "<" ;:}
					| GE {: RESULT = ">=" ;:}
					| LE {: RESULT = "<=" ;:}
					| NE {: RESULT = "<>" ;:};

additiveExpression ::= multiplicativeExpression:me1 additiveExpressionAux:aea1 {: RESULT = (String)me1 + (String)aea1 ;:};

additiveExpressionAux ::= PLUS multiplicativeExpression:me1 additiveExpressionAux:aea1 {: RESULT = "+" + (String)me1 + (String)aea1 ;:}
								| MINUS multiplicativeExpression:me1 additiveExpressionAux:aea1 {: RESULT = "-" + (String)me1 + (String)aea1 ;:}
								| {: RESULT = "" ;:};

multiplicativeExpression ::= unaryExpression:ue1 multiplicativeExpressionAux:mea1 {: RESULT = (String)ue1 + (String)mea1 ;:};

multiplicativeExpressionAux ::= STAR unaryExpression:ue1 multiplicativeExpressionAux:mea1 {: RESULT = "*" + (String)ue1 + (String)mea1  ;:}
								| DIV unaryExpression:ue1 multiplicativeExpressionAux:mea1 {: RESULT = "/" + (String)ue1 + (String)mea1  ;:}
								| {: RESULT = "" ;:};

unaryExpression ::= unaryOperator:uo1 postfixExpression:pfe1 {: RESULT = (String)uo1 + pfe1 ;:}
			     | postfixExpression:pfe1 {: RESULT = pfe1 ;:};

unaryOperator ::= NOT {: RESULT = "not" ;:}
			   | MINUS {: RESULT =  "-" ;:};

postfixExpression ::= primaryExpression:pe1 postfixExpressionAux:pfea1 {: RESULT = pe1 + (String)pfea1  ;:}
				   | SELF featureAccess:fa1 {: RESULT = "SELF" + (String)fa1 ;:}
				   | SELF AROBAPRE {: parser.as.checkStereotype("@pre"); :} featureAccess:fa1 {: RESULT = "SELF" + "@pre" + (String)fa1 ;:};

postfixExpressionAux ::= POINT featureCall:fCall1 postfixExpressionAux:pfea1 {: RESULT = "." + (String)fCall1 + (String)pfea1 ;:}
					  | ARROW featureCall:fCall1 {: parser.as.checkCollectionOperation((String)fCall1); :} postfixExpressionAux:pfea1 {: RESULT = "->" + fCall1 + (String)pfea1 ;:} 
					  | {: RESULT = "" ;:};

featureAccess ::=  POINT featureCall:fCall1 postfixExpressionAux:pfea1 {: RESULT = "." + (String)fCall1 + (String)pfea1 ;:} 
			   | {: RESULT = "" ;:};

primaryExpression ::= litteralCollection:lc1 {: RESULT = (String)lc1 ;:} 
		           | litteral:l1 {: RESULT = l1 ;:}
				   | RESULT {: parser.as.checkStereotype("result"); RESULT = "RESULT" ;:} 
				   | featureCall:fCall1 {: RESULT = (String)fCall1 ;:} 
				   | LPAREN expression:exp1 RPAREN {: RESULT = "(" + (String)exp1 + ")" ;:} 
				   | ifExpression:ifexp1 {: RESULT = (String)ifexp1 ;:};

litteralCollection ::= OCL_COLLECTION:collection1 LCURLY expressionListOrRange:elor1 RCURLY {: RESULT = collection1 + "{" + (String)elor1 + "}" ;:}
						| OCL_COLLECTION:collection1 LCURLY RCURLY {: RESULT = collection1 + "{" + "}" ;:};

expressionListOrRange ::= expression:exp1 COMA expression:exp2 expressionListOrRangeAux:elora1 {: RESULT = (String)exp1 + "," + (String)exp2 + (String)elora1 ;:}
							| expression:exp1 POINT_POINT expression:exp2 {: RESULT = (String)exp1 + ".." + (String)exp2 ;:};

expressionListOrRangeAux ::= COMA expression:exp1 expressionListOrRangeAux:elora1 {: RESULT = "," + (String)exp1 + (String)elora1; :} | {: RESULT = ""; :};

litteral ::= number:n1 {: RESULT = n1; :};

ifExpression ::= IF expression:exp1 THEN expression:exp2 ELSE expression:exp3 ENDIF {: RESULT = "if" + (String)exp1 + "then" + (String)exp2 + "else" + (String)exp3 + "endif"; :};

featureCall ::= pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre"); :} parameters:params1 {: RESULT = (String)pn + "@pre" + (String)params1; :}
				| pathName:pn parameters:params1 {: RESULT = (String)pn + (String)params1; :}
				| pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre"); RESULT = (String)pn + "@pre"; :}
				| pathName:pn {: RESULT	= (String)pn; :};

parameters ::= LPAREN declarator:d1 expression:exp1 RPAREN {: RESULT = "(" + (String)d1 + (String)exp1 + ")"; :}
				| LPAREN declarator:d1 RPAREN {: RESULT = "(" + (String)d1 + ")"; :}
				| LPAREN actualParameterList:apl1 RPAREN {: RESULT = "(" + (String)apl1 + ")"; :};

declarator ::= ID:id declaratorAux:da1 POINTS typeName:tn PIPE {: RESULT = (String)id + (String)da1 + ":" + (String)tn + "|"; :}
				| ID:id declaratorAux:da1 PIPE {: RESULT = (String)id + (String)da1 + "|"; :};

declaratorAux ::= COMA ID:id declaratorAux:da1 {: RESULT = "," + (String)id + (String)da1; :} | {: RESULT = ""; :} ;
			
actualParameterList ::= expression:exp1 actualParameterListAux:apla1 {: RESULT = (String)exp1 + (String)apla1 ; :} | {: RESULT = ""; :};

actualParameterListAux ::= COMA expression:exp1 actualParameterListAux:apla1 {: RESULT = "," + (String)exp1 + (String)apla1 ; :} | {: RESULT = ""; :} ;

typeName ::= pathName:pn {: RESULT = (String)pn; :}
		  | oclType:ocltype1 {: RESULT = (String)ocltype1; :};

oclType ::= OCL_SUPER_TYPE:super1 {: RESULT = super1; :} 
		 | OCL_BASIC_TYPE:basic1 {: RESULT = basic1; :}  
		 | OCL_COLLECTION:collection1 LPAREN typeName:tn RPAREN {: RESULT = collection1 + "(" + (String)tn + ")" ; :};

pathName ::= ID:id pathNameAux:pna {: RESULT = (String)id + (String)pna; :};

pathNameAux ::= FOUR_POINTS ID:id pathNameAux:pna {: RESULT = "::" + (String)id + (String)pna; :} | {: RESULT = "" ; :};

number ::= INT:int1 {: RESULT = int1; :}
		| FLOAT:float1 {: RESULT = float1; :}
		| STRING:string1 {: RESULT = string1; :} 
		| BOOL:bool1 {: RESULT = bool1; :};