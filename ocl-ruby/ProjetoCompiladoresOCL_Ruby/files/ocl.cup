package analisadorSintatico;

/*********************************************************
* Universidade Federal de Campina Grande - UFCG          *
* Centro de Engenharia Eletrica e Informatica - CEEI     *
* Departamento de Sistemas e Computacao - DSC            *
*                                                        *
* Projeto da disciplina de Compiladores, 2011.1          *
* Analisador Sintatico e Semantico para OCL              *
*                                                        *
* Grupo: Francisco Demontie dos Santos Junior - 20911084 *
*        Izabela Vanessa de Almeida Melo - 20811018      *
*        Savyo Igor da Nobrega Santos - 20811034         *
*********************************************************/

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import analisadorSemantico.SemanticAnalyzer;
import analisadorSemantico.Node;

parser code {:
	
	public List<String> log = new ArrayList<String>();
	public List<String> errorLog = new ArrayList<String>();
	public SemanticAnalyzer as = new SemanticAnalyzer();
	
	public Symbol getCurrentToken() {
		return cur_token;
	}
	
	/* Overrides */
	@Override
	public void debug_message(String message) {
		if (message.equals("# Initializing parser"))
			message = "Inicializando o parser";
		if (message.contains("# Goto state #"))
			message = message.replace("# Goto state ", "# Goto para o estado ");
		if (message.contains("# Current Symbol is #")){
			message = message.replace("# Current Symbol is ", "O simbolo atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains("# Current token is #")){
			message = message.replace("# Current token is ", "O token atual eh ");
			int tokenNumber = Integer.valueOf((String) message.subSequence(message.indexOf("#")+1, message.length()));
			message = message.replace(message.subSequence(message.indexOf("#"), message.length()), 
					Tokens.getTokenName(tokenNumber));
		}
		if (message.contains(" Attempting error recovery"))
			message = "\nRotina de tratamento de erros: tentando reparar o erro";
		if (message.contains("Error recovery fails"))
			message = "Recuperacao de erro falhou";
		if (message.contains("Finding recovery state") | message.contains("Pop stack by one") | message.contains("No recovery state"))
			return;
		log.add(message + "\n");
	}
	
	@Override
  	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		debug_message("# Reduce com a producao #" + prod_num + " [NT=" + nt_num
				+ ", " + "SZ=" + rhs_size + "]");
	}

	@Override
	public void debug_shift(Symbol shift_tkn) {
		debug_message("# Shift sob o termo " + Tokens.getTokenName(shift_tkn.sym) + " para o estado #"
				+ shift_tkn.parse_state);
	}
	
	@Override
	public void report_error(String message, Object info) {
		String token = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			if (s.value != null){
				token = s.value.toString();
			} 
			else {
				token = Tokens.getTokenName(s.sym);
			}
			errorLog.add(message + ": token \" " + token + " \"" + " na linha " + (s.left+1));
		}
		else
			errorLog.add(message);
	}
	
	@Override
	public void report_fatal_error(String message, Object info) throws excecoes.FatalErrorException {
		report_error(message, info);
		done_parsing();
		String linha = "";
		if (info instanceof Symbol){
			Symbol s = (Symbol) info;
			linha = " na linha " + (s.left+1);
		}
		throw new excecoes.FatalErrorException("na analise sintatica" + linha);
	}
	
	@Override
	public void syntax_error(Symbol cur_token) {
		report_error("Erro sintatico", cur_token);
	}
	
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws excecoes.FatalErrorException {
		String token = " na linha " + (cur_token.left+1);
		if (cur_token.value != null)
			token = ": token " + cur_token.value + token;
		throw new excecoes.FatalErrorException("na analise sintatica" + token + ". Impossivel reparar e continuar a analise.");
    }
	
:}

/*Terminais*/
terminal CONTEXT, PRE, POST;
terminal IF, THEN, ELSE, ENDIF;
terminal LPAREN, RPAREN, LCURLY, RCURLY;
terminal PIPE, POINT_POINT, COMA;
terminal POINTS, FOUR_POINTS, POINT, ARROW;
terminal STAR, DIV, PLUS, MINUS;
terminal AND, OR, XOR, IMPLIES, NOT;
terminal EQ, LT, LE, GT, GE, NE;
terminal AROBAPRE, SELF, RESULT;
terminal String OCL_SUPER_TYPE, OCL_BASIC_TYPE, OCL_COLLECTION;
terminal String STRING;
terminal Integer INT;
terminal Float FLOAT;
terminal Boolean BOOL;
terminal Object ID;

/*Nao terminais*/
non terminal initialRule, initialRuleAux;
non terminal constraint;
non terminal contextDeclaration, constraintBody, stereotype;
non terminal classifierType, operationContext;
non terminal formalParameterList, formalParameter;
non terminal expression, logicalExpression, logicalOperator;
non terminal relationalExpression, relationalOperator;
non terminal additiveExpression, multiplicativeExpression, unaryExpression, unaryOperator;
non terminal postfixExpression, postfixExpressionAux, featureAccess, primaryExpression;
non terminal litteralCollection, expressionListOrRange, litteral;
non terminal ifExpression, featureCall, parameters;
non terminal actualParameterList, typeName, oclType;
non terminal pathName;
non terminal constraintAux, formalParameterListAux, logicalExpressionAux;
non terminal additiveExpressionAux, multiplicativeExpressionAux;
non terminal expressionListOrRangeAux, declarator, declaratorAux;
non terminal actualParameterListAux, pathNameAux;
non terminal featureCallCollection, collectionParameters;
non terminal relationalExpressionAux;

/*Precedencias*/
precedence left COMA;
precedence left IMPLIES;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NE;
precedence left LT, GT, GE, LE;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT;
precedence left POINT, ARROW;
precedence left AROBAPRE;

/*Regras da gramatica*/
start with initialRule;

initialRule ::= constraint:c1 initialRuleAux:ira1;

initialRuleAux ::= constraint:c1 initialRuleAux:ira1 
				| ;

constraint ::= contextDeclaration:cd1 constraintBody:cb1 constraintAux:ca1;

constraintAux ::= constraintBody:cb1 constraintAux:ca1 
			   | ;

contextDeclaration ::= CONTEXT operationContext:oc1;

constraintBody ::= stereotype:s1 ID:id POINTS expression:exp1
					| stereotype:s1 POINTS expression:exp1;

stereotype ::= PRE {: parser.as.setStereotype("pre"); :}
			| POST {: parser.as.setStereotype("post"); :};

classifierType ::= pathName:pn;

operationContext ::= classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS classifierType:ct2
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN POINTS oclType:ocltype1
					 | classifierType:ct1 LPAREN RPAREN POINTS classifierType:ct2
					 | classifierType:ct1 LPAREN RPAREN POINTS oclType:ocltype1
					 | classifierType:ct1 LPAREN formalParameterList:fpl1 RPAREN
					 | classifierType:ct1 LPAREN RPAREN;

formalParameterList ::= formalParameter:fp1 formalParameterListAux:fpla1;

formalParameterListAux ::= COMA formalParameter:fp1 formalParameterListAux:fpla1 
					    | ;

formalParameter ::= ID:id POINTS typeName:tn;

expression ::= logicalExpression:le1 {: System.out.println("Entrou exp"); RESULT = le1; :};

logicalExpression ::= relationalExpression:re1 logicalExpressionAux:lea1 {: System.out.println("Entrou logical exp"); Node node = new Node(); 
                                                                            if (lea1 == null)
                                                                                node = (Node)re1;
                                                                            else{
                                                                            	String type = parser.as.maxType(((Node)re1).getType(), ((Node)lea1).getType(), re1left);
                                                                                if (type == null)
                                                                                	type = ((Node)lea1).getType();
                                                                                node.setType(type);
                                                                          	}
                                                                          	RESULT = node; 
                                                                          	System.out.println("Tipo logicalExp: " + node.getType());:};

logicalExpressionAux ::= logicalOperator:lo1 relationalExpression:re1 logicalExpressionAux:lea1 {: Node node = new Node(); 
                                                                                     		 	   String type;
                                                                                     		 	   if (lea1 == null){
                                                                                     		 	      type = ((Node)re1).getType();
                                                                                     		 	      if (!type.equals("Boolean")){
                                                                                     		 	         parser.as.error(re1left, "operador " + (String)lo1 + " so eh definido para valores booleanos");
                                                                                        	 	      }
                                                                                        	 	      node.setType(type);
                                                                                        	       } else{
                                                                                     		 	      type = parser.as.maxType(((Node)re1).getType(), ((Node)lea1).getType(), re1left);
                                                                                     		 	      if (type == null)
                                                                                     		 		     type = ((Node)lea1).getType();
                                                                              				 		  node.setType(type);
                                                                          			 		 	   }
                                                                          			 		 	   RESULT = node; :}
					  | ;

logicalOperator ::= AND
			     | OR
				 | XOR
				 | IMPLIES;

relationalExpression ::= additiveExpression:ae1 relationalExpressionAux:rea {: System.out.println("Entrou relational exp");
																			   Node node = new Node();
																			   if (rea == null)
																			      node = (Node)ae1;
																			   else{
                                                                                  String type = parser.as.maxType(((Node)ae1).getType(), ((Node)rea).getType(), ae1left);
                                                                                  if (type == null)
                                                                                     type = ((Node)rea).getType();
                                                                                  node.setType(type);
                                                                          	   }
																			:}
						 | additiveExpression:ae1 {: System.out.println("Entrou relational exp"); RESULT = ae1; :};

relationalExpressionAux ::= relationalOperator:ro1 additiveExpression:ae2 relationalExpressionAux:rea {: Node node = new Node(); 
                                                                                     		 	   		 String type;
                                                                                     		 	   		 type = parser.as.maxType(((Node)ae2).getType(), ((Node)rea).getType(), ae2left);
                                                                                     		 	      	 //ver se eh necessario implementar calculo do valor
                                                                                     		 	      	 node.setType("Boolean");
                                                                          			 		 	   		 RESULT = node; :}
						| relationalOperator:ro1 additiveExpression:ae2 {: RESULT = ae2; :};

relationalOperator ::= EQ
					| GT
					| LT
					| GE
					| LE
					| NE;

additiveExpression ::= multiplicativeExpression:me1 additiveExpressionAux:aea1 {: System.out.println("Entrou additive exp"); 
																				  Node node = parser.as.checkTypesOpArithmetic((Node)me1, (Node)aea1, me1left);
                                                                          		  RESULT = node; 
                                                                          		  System.out.print("Valor addExp: " + node.getValue() + "    ");
                                                                          		  System.out.print("Tipo real do atributo valor: " + node.getValue().getClass());
                                                                          		  System.out.println("Tipo additiveExp: " + node.getType()); :};

additiveExpressionAux ::= PLUS multiplicativeExpression:me1 additiveExpressionAux:aea1 {: Node node = parser.as.checkTypesOpArithmeticAux((Node)me1, (Node)aea1, "+", me1left);
                                                                          			 	 RESULT = node; :}
								| MINUS multiplicativeExpression:me1 additiveExpressionAux:aea1 {: Node node = parser.as.checkTypesOpArithmeticAux((Node)me1, (Node)aea1, "-", me1left);
                                                                          			 		       RESULT = node; :}
								| ;

multiplicativeExpression ::= unaryExpression:ue1 multiplicativeExpressionAux:mea1 {: System.out.println("Entrou mult exp"); 
																					 Node node = parser.as.checkTypesOpArithmetic((Node)ue1, (Node)mea1, ue1left);
                                                                          			 RESULT = node; 
                                                                          			 System.out.print("Valor multExp: " + node.getValue() + "    ");
                                                                          			 System.out.print("Tipo real do atributo valor: " + node.getValue().getClass());
                                                                          			 System.out.println("Tipo multExp: " + node.getType()); :};

multiplicativeExpressionAux ::= STAR unaryExpression:ue1 multiplicativeExpressionAux:mea1 {: Node node = parser.as.checkTypesOpArithmeticAux((Node)ue1, (Node)mea1, "*", ue1left);
                                                                          			 		 RESULT = node; :}
							    
							    | DIV unaryExpression:ue1 multiplicativeExpressionAux:mea1{: if (mea1 == null){
							    																String type = ((Node)ue1).getType();
                                                                                     		 	if (type.equals("Float")){
                                                                                        	 		if ((Float)((Node)ue1).getValue() == 0f)
                                                                                        	 			throw new excecoes.ArithmeticException("divisao por zero na linha " + (ue1left+1));
                                                                                        	 	} else {
                                                                                        	 		if ((Integer)((Node)ue1).getValue() == 0)
                                                                                        	 			throw new excecoes.ArithmeticException("divisao por zero na linha " + (ue1left+1));
                                                                                        	 	}
                                                                                        	 }
                                                                                        	 Node node = parser.as.checkTypesOpArithmeticAux((Node)ue1, (Node)mea1, "/", ue1left);
                                                                                        	 RESULT = node; :}
								| ;

unaryExpression ::= unaryOperator:uo1 postfixExpression:pfe1 {: Node node = (Node)pfe1;
																if (((String)uo1).equals("NOT")){
																	if (node.getType().equals("Integer") || node.getType().equals("Float") || node.getType().equals("String"))
																		parser.as.error(pfe1left, "operador 'NOT' nao eh definido para o tipo " + node.getType());
																	else
																		node.setValue(!((Boolean)node.getValue()));
																} else {
																	if (node.getType().equals("String") || node.getType().equals("Boolean"))
																		parser.as.error(pfe1left, "operador ' - ' nao eh definido para o tipo " + node.getType());
																	else{
																		if (node.getType().equals("Float"))
																			node.setValue(-((Float)node.getValue()));
																		else
																			node.setValue(-((Integer)node.getValue()));
																	}
																}
																RESULT = node;
															 :}
			     | postfixExpression:pfe1 {: System.out.println("Entrou unary exp"); RESULT = pfe1; :};

unaryOperator ::= NOT
			   | MINUS;

postfixExpression ::= primaryExpression:pe1 postfixExpressionAux:pfea1 {: Node node = new Node();
                                                                          if (pfea1 == null){
                                                                          	node = (Node)pe1;
                                                                          }
                                                                          else{
                                                                          	node = (Node)pfea1;
                                                                          }
                                                                          RESULT = node; :}
				   
				   | SELF featureAccess:fa1
				   
				   | SELF AROBAPRE featureAccess:fa1 {: parser.as.checkStereotype("@pre", fa1left); :};

postfixExpressionAux ::= POINT featureCall:fCall1 postfixExpressionAux:pfea1 {: RESULT = new Node("", ""); :}
					  | ARROW featureCallCollection:fCol1 postfixExpressionAux:pfea1 {: System.out.println("Entrou na setinha"); RESULT = new Node("", ""); :}
					  | ;

featureAccess ::=  POINT featureCall:fCall1 postfixExpressionAux:pfea1
			   | ;

primaryExpression ::= litteralCollection:lc1
		           | litteral:l1 {: System.out.println("Entrou primExp como literal: " + ((Node)l1).getValue() + " " + ((Node)l1).getType()); RESULT = l1; :}
				   | RESULT:r {: parser.as.checkStereotype("result", rleft); :} 
				   | featureCall:fCall1 {: System.out.println("Entrou primExp como featureCall"); RESULT = fCall1; :} 
				   | LPAREN expression:exp1 RPAREN {: System.out.println("Entrou primExp");
				   									  Node node = new Node();
				                                      node.setType(((Node)exp1).getType());
				                                      RESULT = node; 
				                                      System.out.println("Tipo primExp: " + node.getType());:}
				   | ifExpression:ifexp1 {: Node node = new Node(); 
				                            node.setType("Boolean");
				                            RESULT = node; 
				                            System.out.println("Tipo primExp: " + node.getType());:};

litteralCollection ::= OCL_COLLECTION:collection1 LCURLY expressionListOrRange:elor1 RCURLY
						| OCL_COLLECTION:collection1 LCURLY RCURLY;

expressionListOrRange ::= expression:exp1 COMA expression:exp2 expressionListOrRangeAux:elora1
							| expression:exp1 POINT_POINT expression:exp2;

expressionListOrRangeAux ::= COMA expression:exp1 expressionListOrRangeAux:elora1;

ifExpression ::= IF expression:exp1 THEN expression:exp2 ELSE expression:exp3 ENDIF;

featureCall ::= pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre", pnleft); :} parameters:params1
				| pathName:pn parameters:params1 {: RESULT	= pn; :}
				| pathName:pn AROBAPRE {: parser.as.checkStereotype("@pre", pnleft); :}
				| pathName:pn {: System.out.println("Entrou no canto certo"); RESULT = new Node(((Node)pn).getValue(), ""); :};

featureCallCollection ::= pathName:pn collectionParameters:params {: 
                      parser.as.checkCollectionOperation(((Node)pn).toString(), ((Node)params).getType(), pnleft);
                      RESULT = new Node("","");
                      :};

collectionParameters ::= LPAREN declarator:d1 expression:exp1 RPAREN
				| LPAREN declarator:d1 RPAREN
				| LPAREN expression:exp1 RPAREN {: System.out.println("Entrou nos parametros com expression");
				 								   Node node = new Node();
				                   				   node.setType(((Node)exp1).getType());
				                   				   RESULT = node;
				                   				   System.out.println("Tipo collPar: " + node.getType()); :}
				| LPAREN RPAREN {: System.out.println("Entrou nos parametros vazios");
				                   Node node = new Node();
				                   node.setType("void");
				                   RESULT = node; :};

parameters ::= LPAREN actualParameterList:apl1 RPAREN;

declarator ::= ID:id declaratorAux:da1 POINTS typeName:tn PIPE {: Node node = (Node)da1;
												  				  node.addElement((String)id);
												  				  RESULT = node; :}
				| ID:id declaratorAux:da1 PIPE {: Node node = (Node)da1;
												  node.addElement((String)id);
												  RESULT = node;
				                                  Iterator<String> it = ((Node)RESULT).iterator();
				                                  while(it.hasNext()){
				                                     System.out.println(it.next());
				                                  }; :} ;

declaratorAux ::= COMA ID:id declaratorAux:da1 {: Node node = (Node)da1;
												  node.addElement((String)id);
												  RESULT = node; :} 
				| {: RESULT = new Node(); :};
			
actualParameterList ::= expression:exp1 actualParameterListAux:apla1 
						| ;

actualParameterListAux ::= COMA expression:exp1 actualParameterListAux:apla1 | ;

typeName ::= pathName:pn
		  | oclType:ocltype1;

oclType ::= OCL_SUPER_TYPE:super1
		 | OCL_BASIC_TYPE:basic1 
		 | OCL_COLLECTION:collection1 LPAREN typeName:tn RPAREN;

pathName ::= ID:id pathNameAux:pna {: System.out.println("Entrou em pathName com " + (String)id + ((Node)pna).toString()); RESULT = new Node((String)id + ((Node)pna).toString()); :};

pathNameAux ::= FOUR_POINTS ID:id pathNameAux:pna {: RESULT = new Node("::" + (String)id + ((Node)pna).toString()); :} 
				| {: RESULT = new Node("") ; :};

litteral ::= INT:int1 {: RESULT = new Node(int1, "Integer"); :}
		| FLOAT:float1 {: RESULT = new Node(float1, "Float"); :}
		| STRING:string1 {: RESULT = new Node(string1, "String"); :} 
		| BOOL:bool1 {: RESULT = new Node(bool1, "Boolean"); :};